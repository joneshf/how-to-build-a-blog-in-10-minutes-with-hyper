// Generated by purs version 0.11.4
"use strict";
var Control_Apply = require("../Control.Apply");
var Control_Semigroupoid = require("../Control.Semigroupoid");
var Data_Array = require("../Data.Array");
var Data_Either = require("../Data.Either");
var Data_Eq = require("../Data.Eq");
var Data_Foldable = require("../Data.Foldable");
var Data_Function = require("../Data.Function");
var Data_Functor = require("../Data.Functor");
var Data_Generic = require("../Data.Generic");
var Data_Maybe = require("../Data.Maybe");
var Data_Monoid = require("../Data.Monoid");
var Data_Newtype = require("../Data.Newtype");
var Data_Path_Pathy = require("../Data.Path.Pathy");
var Data_Semigroup = require("../Data.Semigroup");
var Data_Symbol = require("../Data.Symbol");
var Data_URI = require("../Data.URI");
var Data_URI_Types = require("../Data.URI.Types");
var Data_Unit = require("../Data.Unit");
var Prelude = require("../Prelude");
var Type_Proxy = require("../Type.Proxy");
var Type_Trout = require("../Type.Trout");
var Type_Trout_PathPiece = require("../Type.Trout.PathPiece");
var Link = function (x) {
    return x;
};
var HasLinks = function (toLinks) {
    this.toLinks = toLinks;
};
var toLinks = function (dict) {
    return dict.toLinks;
};
var semigroupLink = new Data_Semigroup.Semigroup(function (v) {
    return function (v1) {
        return Data_Semigroup.append(Data_Semigroup.semigroupArray)(v)(v1);
    };
});
var newtypeLink = new Data_Newtype.Newtype(function (n) {
    return n;
}, Link);
var monoidLink = new Data_Monoid.Monoid(function () {
    return semigroupLink;
}, [  ]);
var linksTo = function (dictHasLinks) {
    return function (x) {
        return toLinks(dictHasLinks)(x)(Data_Monoid.mempty(monoidLink));
    };
};
var linkToURI = function (v) {
    var path = (function () {
        var v1 = Data_Array.unsnoc(v);
        if (v1 instanceof Data_Maybe.Just) {
            return new Data_Either.Right(Data_Path_Pathy.appendPath(Data_Foldable.foldl(Data_Foldable.foldableArray)(Data_Path_Pathy.appendPath)(Data_Path_Pathy.rootDir)(Data_Functor.map(Data_Functor.functorArray)(Data_Path_Pathy.dir)(v1.value0.init)))(Data_Path_Pathy.file(v1.value0.last)));
        };
        if (v1 instanceof Data_Maybe.Nothing) {
            return new Data_Either.Left(Data_Path_Pathy.rootDir);
        };
        throw new Error("Failed pattern match at Type.Trout.Links line 45, column 7 - line 49, column 23: " + [ v1.constructor.name ]);
    })();
    return new Data_URI_Types.URI(Data_Maybe.Nothing.value, new Data_URI_Types.HierarchicalPart(Data_Maybe.Nothing.value, new Data_Maybe.Just(path)), Data_Maybe.Nothing.value, Data_Maybe.Nothing.value);
};
var hasLinksResource = new HasLinks(function (v) {
    return linkToURI;
});
var hasLinksRaw = new HasLinks(function (v) {
    return linkToURI;
});
var hasLinksLit = function (dictHasLinks) {
    return function (dictIsSymbol) {
        return new HasLinks(function (v) {
            var segment = Data_Symbol.reflectSymbol(dictIsSymbol)(Data_Symbol.SProxy.value);
            return function ($46) {
                return toLinks(dictHasLinks)(Type_Proxy["Proxy"].value)(Data_Function.flip(Data_Semigroup.append(semigroupLink))([ segment ])($46));
            };
        });
    };
};
var hasLinksCaptureAll = function (dictHasLinks) {
    return function (dictIsSymbol) {
        return function (dictToPathPiece) {
            return new HasLinks(function (v) {
                return function (l) {
                    return function ($47) {
                        return toLinks(dictHasLinks)(Type_Proxy["Proxy"].value)(Data_Semigroup.append(semigroupLink)(l)(Link(Data_Functor.map(Data_Functor.functorArray)(Type_Trout_PathPiece.toPathPiece(dictToPathPiece))($47))));
                    };
                };
            });
        };
    };
};
var hasLinksCapture = function (dictHasLinks) {
    return function (dictIsSymbol) {
        return function (dictToPathPiece) {
            return new HasLinks(function (v) {
                return function (l) {
                    return function ($48) {
                        return toLinks(dictHasLinks)(Type_Proxy["Proxy"].value)(Data_Semigroup.append(semigroupLink)(l)(Link(Data_Array.singleton(Type_Trout_PathPiece.toPathPiece(dictToPathPiece)($48)))));
                    };
                };
            });
        };
    };
};
var hasLinksAltE = function (dictHasLinks) {
    return function (dictHasLinks1) {
        return new HasLinks(function (v) {
            return function (link) {
                return new Type_Trout.AltE(toLinks(dictHasLinks)(Type_Proxy["Proxy"].value)(link), toLinks(dictHasLinks1)(Type_Proxy["Proxy"].value)(link));
            };
        });
    };
};
var genericLink = new Data_Generic.Generic(function (v) {
    if (v instanceof Data_Generic.SProd && (v.value0 === "Type.Trout.Links.Link" && v.value1.length === 1)) {
        return Control_Apply.apply(Data_Maybe.applyMaybe)(new Data_Maybe.Just(Link))(Data_Generic.fromSpine(Data_Generic.genericArray(Data_Generic.genericString))(v["value1"][0](Data_Unit.unit)));
    };
    return Data_Maybe.Nothing.value;
}, function ($dollarq) {
    return new Data_Generic.SigProd("Type.Trout.Links.Link", [ {
        sigConstructor: "Type.Trout.Links.Link", 
        sigValues: [ function ($dollarq1) {
            return Data_Generic.toSignature(Data_Generic.genericArray(Data_Generic.genericString))(Data_Generic.anyProxy);
        } ]
    } ]);
}, function (v) {
    return new Data_Generic.SProd("Type.Trout.Links.Link", [ function ($dollarq) {
        return Data_Generic.toSpine(Data_Generic.genericArray(Data_Generic.genericString))(v);
    } ]);
});
var eqLink = new Data_Eq.Eq(function (x) {
    return function (y) {
        return Data_Eq.eq(Data_Eq.eqArray(Data_Eq.eqString))(x)(y);
    };
});
module.exports = {
    HasLinks: HasLinks, 
    linksTo: linksTo, 
    toLinks: toLinks, 
    monoidLink: monoidLink, 
    semigroupLink: semigroupLink, 
    newtypeLink: newtypeLink, 
    genericLink: genericLink, 
    eqLink: eqLink, 
    hasLinksLit: hasLinksLit, 
    hasLinksCapture: hasLinksCapture, 
    hasLinksCaptureAll: hasLinksCaptureAll, 
    hasLinksResource: hasLinksResource, 
    hasLinksRaw: hasLinksRaw, 
    hasLinksAltE: hasLinksAltE
};
